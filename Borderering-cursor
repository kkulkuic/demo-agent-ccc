import sys
import re
import argparse
from typing import Optional, List
from playwright.sync_api import sync_playwright, TimeoutError as PlaywrightTimeoutError

"""border_highlight_demo.py

Open a site in headed mode and:
- Draw a visible dot that follows DOM mousemove events.
- Draw a border/highlight overlay around the element under the pointer.

It also supports programmatic targeting (hover/click) by selector or visible text,
so you can test quickly on Wikipedia and other sites.

Examples
  python border_highlight_demo.py https://www.wikipedia.org

  # Hover/click a specific element and keep it highlighted
  python border_highlight_demo.py https://www.wikipedia.org --click-text English --lock-on-click

  # Use a CSS selector
  python border_highlight_demo.py https://www.wikipedia.org --selector "a#js-link-box-en" --no-click

  # Make the border thicker and show a label (tag + id/class)
  python border_highlight_demo.py https://www.wikipedia.org --border-width 4 --show-label

Notes
- The hover highlight works by tracking the real mouse cursor in the page and using
  document.elementFromPoint(x, y) to identify the element.
- This is meant for demos and debugging. Some websites may block automation or
  run inside iframes you canâ€™t access cross-origin.
"""

DOT_JS = r"""
(() => {
  try {
    const old = document.getElementById('__pw_dot');
    if (old) old.remove();

    const dot = document.createElement('div');
    dot.id = '__pw_dot';
    dot.style.cssText = `
      position: fixed;
      left: 200px; top: 200px;
      width: 18px; height: 18px;
      border-radius: 50%;
      background: red;
      z-index: 2147483647;
      pointer-events: none;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 0 4px rgba(255,0,0,0.35), 0 0 14px rgba(255,0,0,0.85);
    `;
    document.documentElement.appendChild(dot);

    if (!window.__pw_dot_follow_installed) {
      window.__pw_dot_follow_installed = true;

      window.addEventListener('mousemove', (e) => {
        const d = document.getElementById('__pw_dot');
        if (!d) return;
        d.style.left = e.clientX + 'px';
        d.style.top  = e.clientY + 'px';
      }, true);

      window.addEventListener('mousedown', (e) => {
        const ring = document.createElement('div');
        ring.style.cssText = `
          position: fixed;
          left:${e.clientX}px; top:${e.clientY}px;
          width: 16px; height: 16px;
          border: 3px solid red;
          border-radius: 50%;
          z-index: 2147483647;
          pointer-events: none;
          transform: translate(-50%, -50%);
          opacity: 0.9;
        `;
        document.documentElement.appendChild(ring);
        setTimeout(() => { try { ring.remove(); } catch(e) {} }, 550);
      }, true);
    }

    true;
  } catch (e) {
    console.log('DOT install error', e);
    false;
  }
})();
"""

# Border/highlight overlay that follows DOM mousemove.
# It draws a fixed-position rectangle (no layout shift) around the element under the pointer.
HILITE_JS = r"""
((opts) => {
  try {
    const {
      borderColor,
      borderWidth,
      borderRadius,
      showLabel,
      lockOnClick,
      ignoreSelectors,
    } = opts || {};

    // Remove old overlay/label if present
    const oldBox = document.getElementById('__pw_hilite_box');
    if (oldBox) oldBox.remove();
    const oldLab = document.getElementById('__pw_hilite_label');
    if (oldLab) oldLab.remove();

    const box = document.createElement('div');
    box.id = '__pw_hilite_box';
    box.style.cssText = `
      position: fixed;
      left: 0; top: 0;
      width: 0; height: 0;
      border: ${borderWidth || 3}px solid ${borderColor || 'deepskyblue'};
      border-radius: ${borderRadius || 6}px;
      z-index: 2147483646;
      pointer-events: none;
      box-sizing: border-box;
      background: rgba(0, 191, 255, 0.06);
    `;
    document.documentElement.appendChild(box);

    let label = null;
    if (showLabel) {
      label = document.createElement('div');
      label.id = '__pw_hilite_label';
      label.style.cssText = `
        position: fixed;
        left: 0; top: 0;
        max-width: 70vw;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
        font-size: 12px;
        line-height: 1.2;
        color: white;
        background: rgba(0,0,0,0.78);
        padding: 4px 6px;
        border-radius: 6px;
        z-index: 2147483647;
        pointer-events: none;
        box-shadow: 0 6px 18px rgba(0,0,0,0.25);
      `;
      document.documentElement.appendChild(label);
    }

    const ignored = new Set([
      '__pw_dot',
      '__pw_hilite_box',
      '__pw_hilite_label'
    ]);

    function shouldIgnore(el) {
      if (!el) return true;
      if (ignored.has(el.id)) return true;
      if (ignoreSelectors && Array.isArray(ignoreSelectors)) {
        for (const sel of ignoreSelectors) {
          try {
            if (sel && el.matches && el.matches(sel)) return true;
          } catch (_) {}
        }
      }
      return false;
    }

    function describe(el) {
      if (!el) return '';
      let s = el.tagName ? el.tagName.toLowerCase() : 'element';
      if (el.id) s += `#${el.id}`;
      if (el.classList && el.classList.length) {
        const cls = Array.from(el.classList).slice(0, 3).join('.');
        if (cls) s += `.${cls}`;
      }
      // add role/aria-label if helpful
      const role = el.getAttribute && el.getAttribute('role');
      const aria = el.getAttribute && (el.getAttribute('aria-label') || el.getAttribute('aria-labelledby'));
      if (role) s += ` [role=${role}]`;
      if (aria && typeof aria === 'string') s += ` [aria=${aria}]`;
      return s;
    }

    let locked = false;
    let last = null;
    let rafPending = false;
    let lastXY = { x: 0, y: 0 };

    function placeOverlay(el, x, y) {
      if (!el) {
        box.style.width = '0px';
        box.style.height = '0px';
        if (label) label.style.display = 'none';
        return;
      }
      const r = el.getBoundingClientRect();
      // If element is offscreen or too small, still draw but avoid negative sizes
      const w = Math.max(0, r.width);
      const h = Math.max(0, r.height);
      box.style.left = `${Math.round(r.left)}px`;
      box.style.top = `${Math.round(r.top)}px`;
      box.style.width = `${Math.round(w)}px`;
      box.style.height = `${Math.round(h)}px`;

      if (label) {
        label.style.display = 'block';
        label.textContent = describe(el);
        // place label near pointer but keep within viewport
        const pad = 10;
        let lx = (x || r.left) + pad;
        let ly = (y || r.top) + pad;
        // clamp a bit
        lx = Math.min(Math.max(0, lx), window.innerWidth - 20);
        ly = Math.min(Math.max(0, ly), window.innerHeight - 20);
        label.style.left = `${Math.round(lx)}px`;
        label.style.top = `${Math.round(ly)}px`;
      }
    }

    function pickElementAt(x, y) {
      // Temporarily hide our overlay so elementFromPoint doesn't return it.
      const prevDisplay = box.style.display;
      box.style.display = 'none';
      if (label) label.style.display = 'none';

      let el = document.elementFromPoint(x, y);

      box.style.display = prevDisplay;
      // label is restored in placeOverlay

      // If we hit a text node wrapper or something odd, climb to an element
      while (el && el.nodeType !== 1) el = el.parentElement;

      if (shouldIgnore(el)) return null;
      return el;
    }

    function onMove(e) {
      if (locked) return;
      lastXY = { x: e.clientX, y: e.clientY };
      if (rafPending) return;
      rafPending = true;
      requestAnimationFrame(() => {
        rafPending = false;
        const el = pickElementAt(lastXY.x, lastXY.y);
        last = el;
        placeOverlay(el, lastXY.x, lastXY.y);
      });
    }

    function onDown(e) {
      if (!lockOnClick) return;
      // lock highlight on whatever is under the pointer
      const el = pickElementAt(e.clientX, e.clientY);
      last = el;
      placeOverlay(el, e.clientX, e.clientY);
      locked = true;
    }

    function unlock() {
      locked = false;
    }

    // Public helper: highlight a specific element (used from Playwright)
    window.__pw_highlight_element = (el, labelText) => {
      try {
        if (!el) return false;
        last = el;
        locked = true;
        placeOverlay(el, 20, 20);
        if (label && labelText) label.textContent = String(labelText);
        return true;
      } catch (_) {
        return false;
      }
    };
    window.__pw_highlight_unlock = unlock;

    // Install listeners once
    if (!window.__pw_hilite_installed) {
      window.__pw_hilite_installed = true;
      window.addEventListener('mousemove', onMove, true);
      window.addEventListener('mousedown', onDown, true);
      // Escape unlocks (handy for lock-on-click)
      window.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          locked = false;
        }
      }, true);
    }

    // If already installed, we still need to update handlers' closures/options.
    // Simple approach: store opts globally for next installs (good enough for demos).
    window.__pw_hilite_opts = opts;

    // Park overlay on initial element under pointer if available
    true;
  } catch (e) {
    console.log('HILITE install error', e);
    return false;
  }
})
"""


def install_dot(page) -> None:
    ok = page.evaluate(DOT_JS)
    exists = page.evaluate("() => !!document.getElementById('__pw_dot')")
    print(f"[dot] install_ok={ok} exists={exists} url={page.url}")
    page.mouse.move(200, 200, steps=1)


def install_highlighter(
    page,
    *,
    border_color: str = "deepskyblue",
    border_width: int = 3,
    border_radius: int = 6,
    show_label: bool = False,
    lock_on_click: bool = False,
    ignore_selectors: Optional[List[str]] = None,
) -> None:
    opts = {
        "borderColor": border_color,
        "borderWidth": int(border_width),
        "borderRadius": int(border_radius),
        "showLabel": bool(show_label),
        "lockOnClick": bool(lock_on_click),
        "ignoreSelectors": ignore_selectors or [],
    }
    ok = page.evaluate(HILITE_JS, opts)
    exists = page.evaluate("() => !!document.getElementById('__pw_hilite_box')")
    print(f"[hilite] install_ok={ok} exists={exists} url={page.url}")


def hover_and_click_locator(page, locator, *, hover_steps=25, hover_pause_ms=250, click=True, highlight=True) -> bool:
    """Hover over an element center, optionally click, and optionally lock-highlight it."""
    try:
        locator.wait_for(state="visible", timeout=8000)
        locator.scroll_into_view_if_needed(timeout=3000)

        box = locator.bounding_box()
        if not box:
            return False

        cx = box["x"] + box["width"] / 2.0
        cy = box["y"] + box["height"] / 2.0

        page.mouse.move(cx, cy, steps=hover_steps)
        if hover_pause_ms:
            page.wait_for_timeout(hover_pause_ms)

        if highlight:
            # Get the underlying element handle and ask the in-page helper to highlight it.
            try:
                handle = locator.element_handle(timeout=2000)
                if handle is not None:
                    page.evaluate("(el) => window.__pw_highlight_element && window.__pw_highlight_element(el)", handle)
            except Exception:
                pass

        if click:
            page.mouse.click(cx, cy)
        return True
    except Exception:
        return False


def find_click_target(page, *, selector: Optional[str] = None, click_text: Optional[str] = None, role: Optional[str] = None):
    """Return a locator for the target using selector/role/text heuristics."""
    if selector:
        return page.locator(selector).first

    if not click_text:
        return None

    roles_to_try = [role] if role else ["button", "link", "menuitem", "tab"]

    for r in roles_to_try:
        # Exact role+name
        try:
            loc = page.get_by_role(r, name=click_text).first
            if loc.count() > 0:
                return loc
        except Exception:
            pass
        # Case-insensitive
        try:
            loc = page.get_by_role(r, name=re.compile(re.escape(click_text), re.I)).first
            if loc.count() > 0:
                return loc
        except Exception:
            pass

    # Fallback: visible text anywhere
    try:
        loc = page.get_by_text(click_text, exact=True).first
        if loc.count() > 0:
            return loc
    except Exception:
        pass
    try:
        loc = page.get_by_text(click_text, exact=False).first
        if loc.count() > 0:
            return loc
    except Exception:
        pass

    return None


def parse_args(argv):
    p = argparse.ArgumentParser(add_help=True)
    p.add_argument("url", nargs="?", default="https://www.wikipedia.org", help="URL to open")

    # Programmatic target
    p.add_argument("--selector", default=None, help="CSS/XPath selector to hover/click")
    p.add_argument("--click-text", default=None, help="Visible text to hover/click")
    p.add_argument("--role", default=None, help="Optional ARIA role (link, button, tab, menuitem) to prioritize")
    p.add_argument("--no-click", action="store_true", help="Only hover (do not click)")

    # Highlighter options
    p.add_argument("--border-color", default="deepskyblue", help="Highlight border color")
    p.add_argument("--border-width", type=int, default=3, help="Highlight border width (px)")
    p.add_argument("--border-radius", type=int, default=6, help="Highlight border radius (px)")
    p.add_argument("--show-label", action="store_true", help="Show a small label for the hovered element")
    p.add_argument("--lock-on-click", action="store_true", help="Lock highlight on mousedown (ESC unlocks)")
    p.add_argument(
        "--ignore-selector",
        action="append",
        default=[],
        help="CSS selector to ignore for hover-picking (can be repeated)",
    )

    p.add_argument("--keep-open-ms", type=int, default=20000, help="How long to keep the browser open at end")
    return p.parse_args(argv)


def main():
    args = parse_args(sys.argv[1:])

    with sync_playwright() as p:
        browser = p.chromium.launch(headless=False, slow_mo=0)
        context = browser.new_context(viewport={"width": 1200, "height": 800})
        page = context.new_page()

        # Install overlays on blank page first (sanity check)
        page.goto("about:blank")
        install_dot(page)
        install_highlighter(
            page,
            border_color=args.border_color,
            border_width=args.border_width,
            border_radius=args.border_radius,
            show_label=args.show_label,
            lock_on_click=args.lock_on_click,
            ignore_selectors=args.ignore_selector,
        )
        page.wait_for_timeout(500)

        # Navigate to target
        page.goto(args.url, wait_until="domcontentloaded")
        try:
            page.wait_for_load_state("networkidle", timeout=8000)
        except PlaywrightTimeoutError:
            pass

        # Reinstall overlays in the new document
        install_dot(page)
        install_highlighter(
            page,
            border_color=args.border_color,
            border_width=args.border_width,
            border_radius=args.border_radius,
            show_label=args.show_label,
            lock_on_click=args.lock_on_click,
            ignore_selectors=args.ignore_selector,
        )
        page.wait_for_timeout(400)

        # Optional: hover/click a target (general-use)
        if args.selector or args.click_text:
            target = find_click_target(page, selector=args.selector, click_text=args.click_text, role=args.role)
            if target is None:
                print("[target] Not found:", args.selector or args.click_text)
            else:
                ok = hover_and_click_locator(page, target, click=(not args.no_click), highlight=True)
                print(f"[target] ok={ok} target={args.selector or args.click_text!r} clicked={not args.no_click}")

        print("[done] Tip: move your mouse around to see borders. If --lock-on-click, click to lock; press ESC to unlock.")
        print(f"[done] Leaving the browser open for {args.keep_open_ms} ms so you can watch.")
        page.wait_for_timeout(max(0, args.keep_open_ms))
        browser.close()


if __name__ == "__main__":
    main()
